// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Retrieve a Single Record
    ///
    /// - Remark: HTTP `GET /Entity`.
    /// - Remark: Generated from `#/paths//Entity/get(EntityEntityGet)`.
    public func EntityEntityGet(_ input: Operations.EntityEntityGet.Input) async throws
        -> Operations.EntityEntityGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.EntityEntityGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Entity", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Entity.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create or Update a single record
    ///
    /// - Remark: HTTP `PATCH /Entity`.
    /// - Remark: Generated from `#/paths//Entity/patch(EntityEntityPatch)`.
    public func EntityEntityPatch(_ input: Operations.EntityEntityPatch.Input) async throws
        -> Operations.EntityEntityPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.EntityEntityPatch.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Entity", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityPatch.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a single record
    ///
    /// - Remark: HTTP `DELETE /Entity`.
    /// - Remark: Generated from `#/paths//Entity/delete(EntityEntityDelete)`.
    public func EntityEntityDelete(_ input: Operations.EntityEntityDelete.Input) async throws
        -> Operations.EntityEntityDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.EntityEntityDelete.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Entity", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityDelete.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityEntityDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a List or DropDown
    ///
    /// - Remark: HTTP `GET /Entity/GetList`.
    /// - Remark: Generated from `#/paths//Entity/GetList/get(EntityGetlistGet)`.
    public func EntityGetlistGet(_ input: Operations.EntityGetlistGet.Input) async throws
        -> Operations.EntityGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.EntityGetlistGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Entity/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ListType",
                    value: input.query.ListType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Status",
                    value: input.query.Status
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityGetlistGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.EntityList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Error400.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Error400.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.EntityGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Error400.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a Single Record
    ///
    /// - Remark: HTTP `GET /GLAccount`.
    /// - Remark: Generated from `#/paths//GLAccount/get(GLAccountGlaccountGet)`.
    public func GLAccountGlaccountGet(_ input: Operations.GLAccountGlaccountGet.Input) async throws
        -> Operations.GLAccountGlaccountGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.GLAccountGlaccountGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/GLAccount", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.GLAccount.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a single record
    ///
    /// - Remark: HTTP `POST /GLAccount`.
    /// - Remark: Generated from `#/paths//GLAccount/post(GLAccountGlaccountPost)`.
    public func GLAccountGlaccountPost(_ input: Operations.GLAccountGlaccountPost.Input) async throws
        -> Operations.GLAccountGlaccountPost.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.GLAccountGlaccountPost.id,
            serializer: { input in let path = try converter.renderedPath(template: "/GLAccount", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPost.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.GLAccountResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPost.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPost.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPost.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update a single record
    ///
    /// - Remark: HTTP `PATCH /GLAccount`.
    /// - Remark: Generated from `#/paths//GLAccount/patch(GLAccountGlaccountPatch)`.
    public func GLAccountGlaccountPatch(_ input: Operations.GLAccountGlaccountPatch.Input) async throws
        -> Operations.GLAccountGlaccountPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.GLAccountGlaccountPatch.id,
            serializer: { input in let path = try converter.renderedPath(template: "/GLAccount", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPatch.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.GLAccountResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountPatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a single record
    ///
    /// - Remark: HTTP `DELETE /GLAccount`.
    /// - Remark: Generated from `#/paths//GLAccount/delete(GLAccountGlaccountDelete)`.
    public func GLAccountGlaccountDelete(_ input: Operations.GLAccountGlaccountDelete.Input) async throws
        -> Operations.GLAccountGlaccountDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.GLAccountGlaccountDelete.id,
            serializer: { input in let path = try converter.renderedPath(template: "/GLAccount", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountDelete.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.GLAccountDelete.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGlaccountDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a List or DropDown
    ///
    /// - Remark: HTTP `GET /GLAccount/GetList`.
    /// - Remark: Generated from `#/paths//GLAccount/GetList/get(GLAccountGetlistGet)`.
    public func GLAccountGetlistGet(_ input: Operations.GLAccountGetlistGet.Input) async throws
        -> Operations.GLAccountGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.GLAccountGetlistGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/GLAccount/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "GLAccountType",
                    value: input.query.GLAccountType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "GLAccountGroup",
                    value: input.query.GLAccountGroup
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "Status",
                    value: input.query.Status
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGetlistGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.GLAccountList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GLAccountGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve the static system Account Types
    ///
    /// - Remark: HTTP `GET /Misc/GetAccountTypes`.
    /// - Remark: Generated from `#/paths//Misc/GetAccountTypes/get(MiscGetaccounttypesGet)`.
    public func MiscGetaccounttypesGet(_ input: Operations.MiscGetaccounttypesGet.Input) async throws
        -> Operations.MiscGetaccounttypesGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.MiscGetaccounttypesGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Misc/GetAccountTypes", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "GLAccountGroup",
                    value: input.query.GLAccountGroup
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetaccounttypesGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountTypesList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetaccounttypesGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetaccounttypesGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetaccounttypesGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a list of US states
    ///
    /// - Remark: HTTP `GET /Misc/GetStates`.
    /// - Remark: Generated from `#/paths//Misc/GetStates/get(MiscGetstatesGet)`.
    public func MiscGetstatesGet(_ input: Operations.MiscGetstatesGet.Input) async throws
        -> Operations.MiscGetstatesGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.MiscGetstatesGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Misc/GetStates", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetstatesGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.StatesList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetstatesGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetstatesGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MiscGetstatesGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a single Main note payable record, as well as a SubRecords array that contains all of the Sub Records
    ///
    /// - Remark: HTTP `GET /NotesPayable`.
    /// - Remark: Generated from `#/paths//NotesPayable/get(NotesPayableNotespayableGet)`.
    public func NotesPayableNotespayableGet(_ input: Operations.NotesPayableNotespayableGet.Input) async throws
        -> Operations.NotesPayableNotespayableGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayableNotespayableGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/NotesPayable", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableNotespayableGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.NotesPayable.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableNotespayableGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableNotespayableGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableNotespayableGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes a Main Note record as well as all Sub Schedule records
    ///
    /// - Remark: HTTP `DELETE /NotesPayable/DeleteMainNote`.
    /// - Remark: Generated from `#/paths//NotesPayable/DeleteMainNote/delete(NotesPayableDeletemainnoteDelete)`.
    public func NotesPayableDeletemainnoteDelete(_ input: Operations.NotesPayableDeletemainnoteDelete.Input)
        async throws -> Operations.NotesPayableDeletemainnoteDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayableDeletemainnoteDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesPayable/DeleteMainNote", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletemainnoteDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletemainnoteDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletemainnoteDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes all Sub Schedule records
    ///
    /// - Remark: HTTP `DELETE /NotesPayable/DeleteSubSchedule`.
    /// - Remark: Generated from `#/paths//NotesPayable/DeleteSubSchedule/delete(NotesPayableDeletesubscheduleDelete)`.
    public func NotesPayableDeletesubscheduleDelete(_ input: Operations.NotesPayableDeletesubscheduleDelete.Input)
        async throws -> Operations.NotesPayableDeletesubscheduleDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayableDeletesubscheduleDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesPayable/DeleteSubSchedule", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletesubscheduleDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletesubscheduleDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableDeletesubscheduleDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a list of records
    ///
    /// - Remark: HTTP `GET /NotesPayable/GetList`.
    /// - Remark: Generated from `#/paths//NotesPayable/GetList/get(NotesPayableGetlistGet)`.
    public func NotesPayableGetlistGet(_ input: Operations.NotesPayableGetlistGet.Input) async throws
        -> Operations.NotesPayableGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayableGetlistGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesPayable/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableGetlistGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.NotesPayableList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayableGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create or Update a single Main note record (Generates a LoanNo and returns it)
    ///
    /// - Remark: HTTP `PATCH /NotesPayable/PatchMainNote`.
    /// - Remark: Generated from `#/paths//NotesPayable/PatchMainNote/patch(NotesPayablePatchmainnotePatch)`.
    public func NotesPayablePatchmainnotePatch(_ input: Operations.NotesPayablePatchmainnotePatch.Input) async throws
        -> Operations.NotesPayablePatchmainnotePatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayablePatchmainnotePatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesPayable/PatchMainNote", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchmainnotePatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchmainnotePatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchmainnotePatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Creates Sub schedule records (Bulk insert of multiple records)
    ///
    /// - Remark: HTTP `PATCH /NotesPayable/PatchSubSchedule`.
    /// - Remark: Generated from `#/paths//NotesPayable/PatchSubSchedule/patch(NotesPayablePatchsubschedulePatch)`.
    public func NotesPayablePatchsubschedulePatch(_ input: Operations.NotesPayablePatchsubschedulePatch.Input)
        async throws -> Operations.NotesPayablePatchsubschedulePatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesPayablePatchsubschedulePatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesPayable/PatchSubSchedule", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchsubschedulePatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchsubschedulePatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesPayablePatchsubschedulePatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a single Main note receivable record, as well as a SubRecords array that contains all of the Sub Records
    ///
    /// - Remark: HTTP `GET /NotesReceivable`.
    /// - Remark: Generated from `#/paths//NotesReceivable/get(NotesReceivableNotesreceivableGet)`.
    public func NotesReceivableNotesreceivableGet(_ input: Operations.NotesReceivableNotesreceivableGet.Input)
        async throws -> Operations.NotesReceivableNotesreceivableGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivableNotesreceivableGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/NotesReceivable", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableNotesreceivableGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.NotesReceivable.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableNotesreceivableGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableNotesreceivableGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableNotesreceivableGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes a Main Note record as well as all Sub Schedule records
    ///
    /// - Remark: HTTP `DELETE /NotesReceivable/DeleteMainNote`.
    /// - Remark: Generated from `#/paths//NotesReceivable/DeleteMainNote/delete(NotesReceivableDeletemainnoteDelete)`.
    public func NotesReceivableDeletemainnoteDelete(_ input: Operations.NotesReceivableDeletemainnoteDelete.Input)
        async throws -> Operations.NotesReceivableDeletemainnoteDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivableDeletemainnoteDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesReceivable/DeleteMainNote", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletemainnoteDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletemainnoteDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletemainnoteDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes all Sub Schedule records
    ///
    /// - Remark: HTTP `DELETE /NotesReceivable/DeleteSubSchedule`.
    /// - Remark: Generated from `#/paths//NotesReceivable/DeleteSubSchedule/delete(NotesReceivableDeletesubscheduleDelete)`.
    public func NotesReceivableDeletesubscheduleDelete(_ input: Operations.NotesReceivableDeletesubscheduleDelete.Input)
        async throws -> Operations.NotesReceivableDeletesubscheduleDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivableDeletesubscheduleDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesReceivable/DeleteSubSchedule", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletesubscheduleDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletesubscheduleDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableDeletesubscheduleDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a list of records
    ///
    /// - Remark: HTTP `GET /NotesReceivable/GetList`.
    /// - Remark: Generated from `#/paths//NotesReceivable/GetList/get(NotesReceivableGetlistGet)`.
    public func NotesReceivableGetlistGet(_ input: Operations.NotesReceivableGetlistGet.Input) async throws
        -> Operations.NotesReceivableGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivableGetlistGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesReceivable/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableGetlistGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.NotesReceivableList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivableGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create or Update a single Main note record (Generates a LoanNo and returns it)
    ///
    /// - Remark: HTTP `PATCH /NotesReceivable/PatchMainNote`.
    /// - Remark: Generated from `#/paths//NotesReceivable/PatchMainNote/patch(NotesReceivablePatchmainnotePatch)`.
    public func NotesReceivablePatchmainnotePatch(_ input: Operations.NotesReceivablePatchmainnotePatch.Input)
        async throws -> Operations.NotesReceivablePatchmainnotePatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivablePatchmainnotePatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesReceivable/PatchMainNote", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchmainnotePatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchmainnotePatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchmainnotePatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Creates Sub schedule records (Bulk insert of multiple records)
    ///
    /// - Remark: HTTP `PATCH /NotesReceivable/PatchSubSchedule`.
    /// - Remark: Generated from `#/paths//NotesReceivable/PatchSubSchedule/patch(NotesReceivablePatchsubschedulePatch)`.
    public func NotesReceivablePatchsubschedulePatch(_ input: Operations.NotesReceivablePatchsubschedulePatch.Input)
        async throws -> Operations.NotesReceivablePatchsubschedulePatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.NotesReceivablePatchsubschedulePatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/NotesReceivable/PatchSubSchedule", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "LoanNo",
                    value: input.query.LoanNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchsubschedulePatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchsubschedulePatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.NotesReceivablePatchsubschedulePatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a Single Record
    ///
    /// - Remark: HTTP `GET /Setup/AccountingDefaults`.
    /// - Remark: Generated from `#/paths//Setup/AccountingDefaults/get(SetupAccountingdefaultsGet)`.
    public func SetupAccountingdefaultsGet(_ input: Operations.SetupAccountingdefaultsGet.Input) async throws
        -> Operations.SetupAccountingdefaultsGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupAccountingdefaultsGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Setup/AccountingDefaults", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update a single record
    ///
    /// - Remark: HTTP `PATCH /Setup/AccountingDefaults`.
    /// - Remark: Generated from `#/paths//Setup/AccountingDefaults/patch(SetupAccountingdefaultsPatch)`.
    public func SetupAccountingdefaultsPatch(_ input: Operations.SetupAccountingdefaultsPatch.Input) async throws
        -> Operations.SetupAccountingdefaultsPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupAccountingdefaultsPatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Setup/AccountingDefaults", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsPatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsPatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupAccountingdefaultsPatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a Single Record
    ///
    /// - Remark: HTTP `GET /Setup/TermsCodes`.
    /// - Remark: Generated from `#/paths//Setup/TermsCodes/get(SetupTermscodesGet)`.
    public func SetupTermscodesGet(_ input: Operations.SetupTermscodesGet.Input) async throws
        -> Operations.SetupTermscodesGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupTermscodesGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Setup/TermsCodes", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Update a single record
    ///
    /// - Remark: HTTP `PATCH /Setup/TermsCodes`.
    /// - Remark: Generated from `#/paths//Setup/TermsCodes/patch(SetupTermscodesPatch)`.
    public func SetupTermscodesPatch(_ input: Operations.SetupTermscodesPatch.Input) async throws
        -> Operations.SetupTermscodesPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupTermscodesPatch.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Setup/TermsCodes", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    request.body = try converter.setRequiredRequestBodyAsString(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesPatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesPatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesPatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Delete a single record
    ///
    /// - Remark: HTTP `DELETE /Setup/TermsCodes`.
    /// - Remark: Generated from `#/paths//Setup/TermsCodes/delete(SetupTermscodesDelete)`.
    public func SetupTermscodesDelete(_ input: Operations.SetupTermscodesDelete.Input) async throws
        -> Operations.SetupTermscodesDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupTermscodesDelete.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Setup/TermsCodes", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupTermscodesDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a list or dropdown
    ///
    /// - Remark: HTTP `GET /Setup/TermsCodes/GetList`.
    /// - Remark: Generated from `#/paths//Setup/TermsCodes/GetList/get(SetupGetlistGet)`.
    public func SetupGetlistGet(_ input: Operations.SetupGetlistGet.Input) async throws
        -> Operations.SetupGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.SetupGetlistGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Setup/TermsCodes/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SetupGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieves the Main transaction record, as well as a SubGrid item that contains all of the Sub Records
    ///
    /// - Remark: HTTP `GET /Transaction`.
    /// - Remark: Generated from `#/paths//Transaction/get(TransactionTransactionGet)`.
    public func TransactionTransactionGet(_ input: Operations.TransactionTransactionGet.Input) async throws
        -> Operations.TransactionTransactionGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionTransactionGet.id,
            serializer: { input in let path = try converter.renderedPath(template: "/Transaction", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransTypeName",
                    value: input.query.TransTypeName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransNo",
                    value: input.query.TransNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionTransactionGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.TransactionRecordResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionTransactionGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionTransactionGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionTransactionGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes a Main transaction record as well as all Sub records
    ///
    /// - Remark: HTTP `DELETE /Transaction/DeleteMain`.
    /// - Remark: Generated from `#/paths//Transaction/DeleteMain/delete(TransactionDeletemainDelete)`.
    public func TransactionDeletemainDelete(_ input: Operations.TransactionDeletemainDelete.Input) async throws
        -> Operations.TransactionDeletemainDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionDeletemainDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/DeleteMain", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransTypeName",
                    value: input.query.TransTypeName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransNo",
                    value: input.query.TransNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletemainDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletemainDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletemainDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes a Sub transaction record (Also updates the current balance on the Main record and returns it)
    ///
    /// - Remark: HTTP `DELETE /Transaction/DeleteSub`.
    /// - Remark: Generated from `#/paths//Transaction/DeleteSub/delete(TransactionDeletesubDelete)`.
    public func TransactionDeletesubDelete(_ input: Operations.TransactionDeletesubDelete.Input) async throws
        -> Operations.TransactionDeletesubDelete.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionDeletesubDelete.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/DeleteSub", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransTypeName",
                    value: input.query.TransTypeName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransNo",
                    value: input.query.TransNo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletesubDelete.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletesubDelete.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionDeletesubDelete.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieve a list of records (Specifically for Transaction Listings that aren't registers)
    ///
    /// - Remark: HTTP `GET /Transaction/GetList`.
    /// - Remark: Generated from `#/paths//Transaction/GetList/get(TransactionGetlistGet)`.
    public func TransactionGetlistGet(_ input: Operations.TransactionGetlistGet.Input) async throws
        -> Operations.TransactionGetlistGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionGetlistGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/GetList", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransListType",
                    value: input.query.TransListType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StartDate",
                    value: input.query.StartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "EndDate",
                    value: input.query.EndDate
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetlistGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.TransactionList.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetlistGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetlistGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetlistGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Retrieves a list with a running balance
    ///
    /// - Remark: HTTP `GET /Transaction/GetRegister`.
    /// - Remark: Generated from `#/paths//Transaction/GetRegister/get(TransactionGetregisterGet)`.
    public func TransactionGetregisterGet(_ input: Operations.TransactionGetregisterGet.Input) async throws
        -> Operations.TransactionGetregisterGet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionGetregisterGet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/GetRegister", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "RegisterType",
                    value: input.query.RegisterType
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "AccountNo",
                    value: input.query.AccountNo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "StartDate",
                    value: input.query.StartDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "EndDate",
                    value: input.query.EndDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "EntityID",
                    value: input.query.EntityID
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetregisterGet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.TransactionRegister.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetregisterGet.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetregisterGet.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionGetregisterGet.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create or Update a single Main transaction record (Generates a TransNo and returns it)
    ///
    /// - Remark: HTTP `PATCH /Transaction/PatchMain`.
    /// - Remark: Generated from `#/paths//Transaction/PatchMain/patch(TransactionPatchmainPatch)`.
    public func TransactionPatchmainPatch(_ input: Operations.TransactionPatchmainPatch.Input) async throws
        -> Operations.TransactionPatchmainPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionPatchmainPatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/PatchMain", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransNo",
                    value: input.query.TransNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchmainPatch.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.TransactionPatchResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchmainPatch.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchmainPatch.Output.UnprocessableEntity.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unprocessableEntity(.init(body: body))
                case 500:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchmainPatch.Output.InternalServerError.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .internalServerError(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Creates a single Sub transaction record (Also updates the current balance on the Main record and returns it)
    ///
    /// - Remark: HTTP `PATCH /Transaction/PatchSub`.
    /// - Remark: Generated from `#/paths//Transaction/PatchSub/patch(TransactionPatchsubPatch)`.
    public func TransactionPatchsubPatch(_ input: Operations.TransactionPatchsubPatch.Input) async throws
        -> Operations.TransactionPatchsubPatch.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.TransactionPatchsubPatch.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/Transaction/PatchSub", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransTypeName",
                    value: input.query.TransTypeName
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "TransNo",
                    value: input.query.TransNo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "IDNo",
                    value: input.query.IDNo
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchsubPatch.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.TransactionPatchSubResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TransactionPatchsubPatch.Output.Default.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommonErrorResponse.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.statusCode, .init(body: body))
                }
            }
        )
    }
}
